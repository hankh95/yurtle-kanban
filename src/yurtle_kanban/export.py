"""
Export functionality for yurtle-kanban.

Provides export to:
- HTML (standalone, GitHub Pages compatible)
- Markdown (table format)
- JSON (for integrations)
"""

import json
from datetime import datetime
from typing import Any

from .models import Board, WorkItem, WorkItemStatus


def export_html(board: Board) -> str:
    """Export board to standalone HTML."""
    # Group items by status
    items_by_status: dict[str, list[WorkItem]] = {}
    for col in board.columns:
        try:
            status = WorkItemStatus.from_string(col.id)
            items_by_status[col.id] = board.get_items_by_status(status)
        except ValueError:
            items_by_status[col.id] = []

    # Build HTML
    columns_html = []
    for col in board.columns:
        items = items_by_status.get(col.id, [])
        items_html = "\n".join(_render_html_card(item) for item in items)

        wip_class = ""
        wip_badge = ""
        if col.wip_limit:
            if len(items) > col.wip_limit:
                wip_class = "wip-exceeded"
            wip_badge = f'<span class="wip-badge">{len(items)}/{col.wip_limit}</span>'

        columns_html.append(f"""
        <div class="column {wip_class}">
            <h2>{col.name} <span class="count">({len(items)})</span> {wip_badge}</h2>
            <div class="cards">
                {items_html or '<p class="empty">No items</p>'}
            </div>
        </div>
        """)

    return f"""<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>{board.name}</title>
    <style>
        :root {{
            --bg-color: #1a1a2e;
            --card-bg: #16213e;
            --text-color: #eee;
            --border-color: #0f3460;
            --accent-color: #e94560;
        }}

        * {{ box-sizing: border-box; }}

        body {{
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 20px;
        }}

        h1 {{
            text-align: center;
            margin-bottom: 30px;
        }}

        .board {{
            display: flex;
            gap: 20px;
            overflow-x: auto;
            padding-bottom: 20px;
        }}

        .column {{
            flex: 0 0 300px;
            background: var(--card-bg);
            border-radius: 8px;
            padding: 15px;
        }}

        .column.wip-exceeded {{
            border: 2px solid var(--accent-color);
        }}

        .column h2 {{
            font-size: 1rem;
            margin: 0 0 15px 0;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
        }}

        .count {{
            opacity: 0.6;
            font-weight: normal;
        }}

        .wip-badge {{
            background: var(--accent-color);
            color: white;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.8rem;
            margin-left: 5px;
        }}

        .cards {{
            display: flex;
            flex-direction: column;
            gap: 10px;
        }}

        .card {{
            background: var(--bg-color);
            border-radius: 6px;
            padding: 12px;
            border-left: 3px solid var(--border-color);
        }}

        .card.priority-critical {{ border-left-color: #ef4444; }}
        .card.priority-high {{ border-left-color: #f59e0b; }}
        .card.priority-medium {{ border-left-color: #3b82f6; }}
        .card.priority-low {{ border-left-color: #6b7280; }}

        .card-id {{
            font-size: 0.8rem;
            color: #888;
            margin-bottom: 5px;
        }}

        .card-title {{
            font-weight: 500;
            margin-bottom: 8px;
        }}

        .card-meta {{
            font-size: 0.8rem;
            color: #888;
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }}

        .tag {{
            background: var(--border-color);
            padding: 2px 6px;
            border-radius: 4px;
            font-size: 0.75rem;
        }}

        .empty {{
            color: #666;
            text-align: center;
            padding: 20px;
        }}

        footer {{
            text-align: center;
            margin-top: 30px;
            color: #666;
            font-size: 0.8rem;
        }}

        @media (max-width: 768px) {{
            .board {{
                flex-direction: column;
            }}
            .column {{
                flex: none;
                width: 100%;
            }}
        }}
    </style>
</head>
<body>
    <h1>{board.name}</h1>

    <div class="board">
        {''.join(columns_html)}
    </div>

    <footer>
        Generated by yurtle-kanban on {datetime.now().strftime('%Y-%m-%d %H:%M')}
    </footer>
</body>
</html>"""


def _render_html_card(item: WorkItem) -> str:
    """Render a work item as an HTML card."""
    tags_html = " ".join(f'<span class="tag">{tag}</span>' for tag in item.tags[:3])

    return f"""
    <div class="card priority-{item.priority or 'medium'}">
        <div class="card-id">{item.item_type.value.upper()} {item.id}</div>
        <div class="card-title">{item.title}</div>
        <div class="card-meta">
            {f'<span>@{item.assignee}</span>' if item.assignee else ''}
            {tags_html}
        </div>
    </div>
    """


def export_markdown(board: Board) -> str:
    """Export board to markdown table format."""
    lines = [
        f"# {board.name}",
        "",
        f"*Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}*",
        "",
    ]

    # Create table header
    header = "| " + " | ".join(col.name for col in board.columns) + " |"
    separator = "| " + " | ".join("---" for _ in board.columns) + " |"

    lines.append(header)
    lines.append(separator)

    # Group items by status
    items_by_status: dict[str, list[WorkItem]] = {}
    for col in board.columns:
        try:
            status = WorkItemStatus.from_string(col.id)
            items_by_status[col.id] = board.get_items_by_status(status)
        except ValueError:
            items_by_status[col.id] = []

    # Find max items
    max_items = max(len(items) for items in items_by_status.values()) if items_by_status else 0

    # Add rows
    for i in range(max(max_items, 1)):
        row = []
        for col in board.columns:
            items = items_by_status.get(col.id, [])
            if i < len(items):
                item = items[i]
                row.append(f"**{item.id}** {item.title[:20]}...")
            else:
                row.append("")
        lines.append("| " + " | ".join(row) + " |")

    lines.append("")

    # Add statistics
    lines.append("## Statistics")
    lines.append("")
    lines.append("| Status | Count |")
    lines.append("| --- | --- |")

    counts = board.get_column_counts()
    for col in board.columns:
        count = counts.get(col.id, 0)
        lines.append(f"| {col.name} | {count} |")

    lines.append(f"| **Total** | **{sum(counts.values())}** |")

    return "\n".join(lines)


def export_expedition_index(board: Board, min_id: int = 600) -> str:
    """Export an enhanced expedition index with Work Trail and Dependency Tree.

    Features:
    - Enhanced table with Agent, Depends, For columns
    - Work Trail (items >= min_id) with dependency hierarchy
    - Dependency Tree for active development items

    Args:
        board: The kanban board with all items
        min_id: Minimum item number for Work Trail section (default: 600)

    Returns:
        Markdown formatted expedition index
    """
    lines = [
        "# Expedition Index",
        "",
        f"*Generated: {datetime.now().strftime('%Y-%m-%d %H:%M')}*",
        "",
    ]

    # Filter to expedition-type items and sort by ID
    expeditions = [
        item for item in board.items
        if item.item_type.value in ("expedition", "feature", "epic")
    ]
    expeditions.sort(key=lambda x: _extract_id_number(x.id), reverse=True)

    # =========================================================================
    # Section 1: Enhanced Expeditions Table
    # =========================================================================
    lines.extend([
        "## Expeditions",
        "",
        "| # | Title | Status | Pri | Agent | Depends | For |",
        "|---|-------|--------|-----|-------|---------|-----|",
    ])

    for item in expeditions:
        num = _extract_id_number(item.id)
        title = item.title[:50] + "..." if len(item.title) > 50 else item.title
        status = _status_emoji(item.status)
        priority = str(item.priority or "medium").upper()[:4]
        agent = _format_assignee(item.assignee)
        depends = _format_dependencies(item.depends_on)
        purpose = _infer_purpose(item.tags)

        lines.append(f"| {num} | {title} | {status} | {priority} | {agent} | {depends} | {purpose} |")

    lines.extend([
        "",
        "**Legend:** ðŸ”„ Active | ðŸŸ¢ Ready | ðŸŸ¡ Blocked/Harbor | âœ… Done | âŒ Stranded",
        "",
    ])

    # =========================================================================
    # Section 2: Work Trail (items >= min_id)
    # =========================================================================
    recent_items = [
        item for item in expeditions
        if _extract_id_number(item.id) >= min_id
    ]

    if recent_items:
        lines.extend([
            f"## Work Trail ({min_id} and up)",
            "",
            "*What we were trying to do â†’ what we had to do first. Indentation = sidetrack.*",
            "",
        ])

        # Build dependency graph for indentation
        dep_graph = _build_dependency_graph(recent_items)

        # Group by date if available, otherwise by status
        done_items = [i for i in recent_items if i.status == WorkItemStatus.DONE]
        active_items = [i for i in recent_items if i.status == WorkItemStatus.IN_PROGRESS]
        ready_items = [i for i in recent_items if i.status == WorkItemStatus.READY]
        other_items = [i for i in recent_items if i.status not in (
            WorkItemStatus.DONE, WorkItemStatus.IN_PROGRESS, WorkItemStatus.READY
        )]

        # Show active items first
        for item in active_items:
            indent = _get_dependency_indent(item, dep_graph)
            num = _extract_id_number(item.id)
            status_emoji = "ðŸ”„"
            short_title = item.title.split(":")[0] if ":" in item.title else item.title[:40]
            deps = _format_dependencies(item.depends_on) or "-"
            lines.append(f"{indent}- **{item.created or 'WIP'}** {num} {status_emoji} {short_title}")
            if item.depends_on:
                lines.append(f"{indent}  - Depends: {deps}")

        # Show ready items
        for item in ready_items:
            indent = _get_dependency_indent(item, dep_graph)
            num = _extract_id_number(item.id)
            status_emoji = "ðŸŸ¢"
            short_title = item.title.split(":")[0] if ":" in item.title else item.title[:40]
            lines.append(f"{indent}- **READY** {num} {status_emoji} {short_title}")

        # Show recently done items (last 10)
        for item in done_items[:10]:
            indent = _get_dependency_indent(item, dep_graph)
            num = _extract_id_number(item.id)
            status_emoji = "âœ…"
            short_title = item.title.split(":")[0] if ":" in item.title else item.title[:40]
            lines.append(f"{indent}- **DONE** {num} {status_emoji} {short_title}")

        lines.append("")

    # =========================================================================
    # Section 3: Dependency Tree (active development)
    # =========================================================================
    active_or_ready = [
        item for item in expeditions
        if item.status in (WorkItemStatus.IN_PROGRESS, WorkItemStatus.READY, WorkItemStatus.REVIEW)
    ]

    if active_or_ready:
        lines.extend([
            "## Dependency Tree (Active Development)",
            "",
            "```",
            "Active Work Dependencies",
            "â”‚",
        ])

        # Build tree structure
        for item in active_or_ready[:15]:  # Limit to 15 items
            num = _extract_id_number(item.id)
            short_title = item.title.split(":")[0] if ":" in item.title else item.title[:35]
            status_str = _status_bracket(item.status)
            deps = _format_dependencies(item.depends_on) or "none"

            lines.append(f"â”œâ”€â”€ {num} {short_title} [{status_str}]")
            lines.append(f"â”‚     Depends: {deps}")

        lines.extend([
            "```",
            "",
        ])

    return "\n".join(lines)


def _extract_id_number(item_id: str) -> int:
    """Extract numeric ID from item ID like 'EXP-732'."""
    import re
    match = re.search(r'\d+', item_id)
    return int(match.group()) if match else 0


def _status_emoji(status: WorkItemStatus) -> str:
    """Convert status to emoji indicator."""
    emoji_map = {
        WorkItemStatus.DONE: "âœ…",
        WorkItemStatus.IN_PROGRESS: "ðŸ”„",
        WorkItemStatus.READY: "ðŸŸ¢",
        WorkItemStatus.REVIEW: "ðŸ”",
        WorkItemStatus.BLOCKED: "ðŸŸ¡",
        WorkItemStatus.BACKLOG: "ðŸ“‹",
    }
    return emoji_map.get(status, "â¬œ")


def _status_bracket(status: WorkItemStatus) -> str:
    """Convert status to bracket indicator."""
    status_map = {
        WorkItemStatus.DONE: "DONE",
        WorkItemStatus.IN_PROGRESS: "ACTIVE",
        WorkItemStatus.READY: "READY",
        WorkItemStatus.REVIEW: "REVIEW",
        WorkItemStatus.BLOCKED: "BLOCKED",
        WorkItemStatus.BACKLOG: "BACKLOG",
    }
    return status_map.get(status, "UNKNOWN")


def _format_assignee(assignee: str | None) -> str:
    """Format assignee for table display."""
    if not assignee:
        return "-"
    # Handle common formats
    assignee_str = str(assignee)
    if "agent-a" in assignee_str.lower():
        return "A"
    if "agent-b" in assignee_str.lower():
        return "B"
    if assignee_str.startswith("<") and assignee_str.endswith(">"):
        # Handle URIs like <agent-b>
        inner = assignee_str[1:-1]
        if "agent-a" in inner.lower():
            return "A"
        if "agent-b" in inner.lower():
            return "B"
        return inner[:10]
    return assignee_str[:10]


def _format_dependencies(depends_on: list[str]) -> str:
    """Format dependencies as comma-separated numbers."""
    if not depends_on:
        return "-"
    nums = []
    for dep in depends_on:
        num = _extract_id_number(str(dep))
        if num > 0:
            status_suffix = ""  # Could add âœ… if we knew the status
            nums.append(f"{num}{status_suffix}")
    return ",".join(nums) if nums else "-"


def _infer_purpose(tags: list[str]) -> str:
    """Infer purpose/project from tags."""
    if not tags:
        return "-"
    # Common tag mappings
    purpose_map = {
        "v9": "V9",
        "p108": "P108",
        "p111": "P111",
        "p115": "P115",
        "cog": "COG",
        "y-layer": "Y-Layer",
        "training": "Train",
        "testing": "Test",
        "mac": "Mac",
        "gpu": "GPU",
        "performance": "Perf",
        "tooling": "Tool",
    }
    purposes = []
    for tag in tags:
        tag_lower = tag.lower()
        for key, val in purpose_map.items():
            if key in tag_lower:
                purposes.append(val)
                break
    return ",".join(purposes[:2]) if purposes else tags[0][:6] if tags else "-"


def _build_dependency_graph(items: list[WorkItem]) -> dict[str, list[str]]:
    """Build a graph of item dependencies."""
    graph: dict[str, list[str]] = {}
    for item in items:
        item_num = str(_extract_id_number(item.id))
        dep_nums = [str(_extract_id_number(d)) for d in (item.depends_on or [])]
        graph[item_num] = dep_nums
    return graph


def _get_dependency_indent(item: WorkItem, dep_graph: dict[str, list[str]]) -> str:
    """Calculate indent based on dependency depth."""
    # Simple heuristic: if this item is depended on by others, no indent
    # If this item depends on others, indent
    item_num = str(_extract_id_number(item.id))

    # Check if any item depends on this one
    is_depended_on = any(item_num in deps for deps in dep_graph.values())

    if is_depended_on:
        return ""
    elif item.depends_on:
        return "  "
    else:
        return ""


def export_json(board: Board) -> str:
    """Export board to JSON format."""
    data: dict[str, Any] = {
        "board": {
            "id": board.id,
            "name": board.name,
            "generated_at": datetime.now().isoformat(),
        },
        "columns": [],
        "items": [],
        "statistics": {},
    }

    # Add columns
    for col in board.columns:
        data["columns"].append({
            "id": col.id,
            "name": col.name,
            "order": col.order,
            "wip_limit": col.wip_limit,
        })

    # Add items
    for item in board.items:
        data["items"].append(item.to_dict())

    # Add statistics
    counts = board.get_column_counts()
    data["statistics"] = {
        "by_status": counts,
        "total": sum(counts.values()),
    }

    return json.dumps(data, indent=2)
